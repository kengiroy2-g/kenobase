#!/usr/bin/env python3
"""Backtest Lag-Exploitation Strategy: KENO->AUSWAHLWETTE lag=7.

Based on ecosystem_graph.json finding:
- Trigger: Number 11 appears in KENO draw
- Target: Number 25 appears in AUSWAHLWETTE 7 days later
- Lift: 2.41x (conditional rate 34% vs baseline 14.1%)
- q-value: 0.027 (significant at FDR=0.05)

Strategy:
- When KENO draws 11 on day D, bet on number 25 in AUSWAHLWETTE on day D+7

Usage:
    python scripts/backtest_lag_exploitation.py
"""

from __future__ import annotations

import argparse
import json
import logging
from dataclasses import dataclass
from datetime import datetime, timedelta
from pathlib import Path
from typing import Optional

import numpy as np
import pandas as pd

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)


# ============================================================
# Edge Parameters (from ecosystem_graph.json)
# ============================================================
TRIGGER_NUMBER = 11  # Number in KENO that triggers signal
TARGET_NUMBER = 25   # Number in AUSWAHLWETTE to bet on
LAG_DAYS = 7         # Days between KENO trigger and AUSWAHLWETTE bet
BASE_RATE = 0.1408   # Baseline probability of 25 appearing in AW (14.08%)
EXPECTED_LIFT = 2.41 # Expected lift from ecosystem analysis

# Train/Test Split
TRAIN_END = "2023-12-31"
TEST_START = "2024-01-01"

# AUSWAHLWETTE: 6 numbers from 1-49, weekly on Saturdays
# Matching 1 number: no payout (need at least 2 for Lotto-style)
# For simplicity, we assume a flat bet on "number 25 appears" as a proposition
# In reality, AUSWAHLWETTE payouts depend on match tier
# We use a simplified model: if 25 appears, payout = 1/base_rate = ~7.1x
SIMPLIFIED_PAYOUT = 1.0 / BASE_RATE  # ~7.1 if 25 appears


@dataclass
class BetOpportunity:
    """Single betting opportunity."""
    keno_date: datetime
    trigger_fired: bool  # Did KENO draw 11?
    aw_date: datetime    # AUSWAHLWETTE draw date (D+7)
    aw_exists: bool      # Does this AW draw exist?
    target_hit: bool     # Did AW draw 25?
    period: str          # TRAIN or TEST


@dataclass
class BacktestResult:
    """Complete backtest results."""
    strategy: str
    trigger_number: int
    target_number: int
    lag_days: int
    train_metrics: dict
    test_metrics: dict
    null_model: dict
    overall_summary: dict
    acceptance_criteria: dict
    generated_at: str


def load_keno_data(filepath: str) -> pd.DataFrame:
    """Load KENO CSV data."""
    df = pd.read_csv(filepath, sep=";", encoding="utf-8")
    df["Datum"] = pd.to_datetime(df["Datum"], format="%d.%m.%Y")
    # Extract all KENO numbers into a set per row
    num_cols = [f"Keno_Z{i}" for i in range(1, 21)]
    df["numbers"] = df[num_cols].apply(lambda row: set(row.values), axis=1)
    return df[["Datum", "numbers"]].copy()


def load_aw_data(filepath: str) -> pd.DataFrame:
    """Load AUSWAHLWETTE CSV data."""
    df = pd.read_csv(filepath, sep=";", encoding="utf-8")
    df["Datum"] = pd.to_datetime(df["Datum"], format="%d.%m.%Y")
    # Extract A1-A6 numbers into a set per row
    num_cols = ["A1", "A2", "A3", "A4", "A5", "A6"]
    df["numbers"] = df[num_cols].apply(lambda row: set(row.values), axis=1)
    return df[["Datum", "numbers"]].copy()


def find_bet_opportunities(
    keno_df: pd.DataFrame,
    aw_df: pd.DataFrame,
    trigger_num: int,
    target_num: int,
    lag: int,
) -> list[BetOpportunity]:
    """Find all potential betting opportunities.

    For each KENO draw, check if trigger number appears.
    If yes, find the AUSWAHLWETTE draw that is exactly `lag` days later.
    """
    opportunities = []

    # Create AW lookup by date
    aw_by_date = {row["Datum"]: row["numbers"] for _, row in aw_df.iterrows()}

    train_end = pd.to_datetime(TRAIN_END)
    test_start = pd.to_datetime(TEST_START)

    for _, keno_row in keno_df.iterrows():
        keno_date = keno_row["Datum"]
        trigger_fired = trigger_num in keno_row["numbers"]

        # Calculate target AUSWAHLWETTE date
        aw_target_date = keno_date + timedelta(days=lag)

        # Find closest AW draw (AW is weekly on Saturdays)
        # Look for exact match first, then within 1 day tolerance
        aw_exists = False
        target_hit = False
        actual_aw_date = aw_target_date

        for delta in [0, 1, -1, 2, -2]:
            check_date = aw_target_date + timedelta(days=delta)
            if check_date in aw_by_date:
                aw_exists = True
                actual_aw_date = check_date
                target_hit = target_num in aw_by_date[check_date]
                break

        # Determine period
        if keno_date <= train_end:
            period = "TRAIN"
        elif keno_date >= test_start:
            period = "TEST"
        else:
            period = "GAP"

        opportunities.append(BetOpportunity(
            keno_date=keno_date,
            trigger_fired=trigger_fired,
            aw_date=actual_aw_date,
            aw_exists=aw_exists,
            target_hit=target_hit,
            period=period,
        ))

    return opportunities


def compute_metrics(opportunities: list[BetOpportunity], period: str) -> dict:
    """Compute metrics for a given period."""
    period_opps = [o for o in opportunities if o.period == period]

    # Filter to opportunities where trigger fired AND AW draw exists
    triggered = [o for o in period_opps if o.trigger_fired and o.aw_exists]

    if not triggered:
        return {
            "n_opportunities": 0,
            "n_hits": 0,
            "hit_rate": 0.0,
            "lift": 0.0,
            "total_bets": 0,
            "total_wins": 0,
            "roi_pct": 0.0,
            "roi_per_bet": 0.0,
        }

    n_opportunities = len(triggered)
    n_hits = sum(1 for o in triggered if o.target_hit)
    hit_rate = n_hits / n_opportunities if n_opportunities > 0 else 0.0
    lift = hit_rate / BASE_RATE if BASE_RATE > 0 else 0.0

    # ROI calculation (simplified model)
    # Bet: 1 unit per opportunity
    # Win: SIMPLIFIED_PAYOUT if target hit, 0 otherwise
    total_bets = n_opportunities  # Total units wagered
    total_wins = n_hits * SIMPLIFIED_PAYOUT  # Total units won
    profit = total_wins - total_bets
    roi_pct = (profit / total_bets) * 100 if total_bets > 0 else 0.0
    roi_per_bet = profit / n_opportunities if n_opportunities > 0 else 0.0

    return {
        "n_opportunities": n_opportunities,
        "n_hits": n_hits,
        "hit_rate": hit_rate,
        "lift": lift,
        "total_bets": total_bets,
        "total_wins": float(total_wins),
        "profit": float(profit),
        "roi_pct": roi_pct,
        "roi_per_bet": roi_per_bet,
        "payout_multiplier": SIMPLIFIED_PAYOUT,
    }


def run_null_model(
    opportunities: list[BetOpportunity],
    period: str,
    n_permutations: int = 1000,
) -> dict:
    """Run schedule-preserving permutation null model.

    Permutes the AW outcomes while preserving the weekday structure.
    This tests whether the observed lift could occur by chance.
    """
    period_opps = [o for o in opportunities if o.period == period]
    triggered = [o for o in period_opps if o.trigger_fired and o.aw_exists]

    if len(triggered) < 5:
        return {
            "n_permutations": 0,
            "null_lifts": [],
            "observed_lift": 0.0,
            "p_value": 1.0,
            "is_significant": False,
        }

    observed_hits = sum(1 for o in triggered if o.target_hit)
    observed_lift = (observed_hits / len(triggered)) / BASE_RATE

    # Get all AW outcomes for permutation
    all_aw_outcomes = [o.target_hit for o in period_opps if o.aw_exists]

    null_lifts = []
    rng = np.random.default_rng(42)

    for _ in range(n_permutations):
        # Shuffle AW outcomes
        shuffled = rng.permutation(all_aw_outcomes)

        # Assign shuffled outcomes to triggered opportunities
        shuffled_hits = sum(shuffled[:len(triggered)])
        null_lift = (shuffled_hits / len(triggered)) / BASE_RATE
        null_lifts.append(null_lift)

    # P-value: proportion of null lifts >= observed
    p_value = np.mean(np.array(null_lifts) >= observed_lift)

    return {
        "n_permutations": n_permutations,
        "null_mean_lift": float(np.mean(null_lifts)),
        "null_std_lift": float(np.std(null_lifts)),
        "null_95_percentile": float(np.percentile(null_lifts, 95)),
        "observed_lift": observed_lift,
        "p_value": float(p_value),
        "is_significant": p_value < 0.05,
    }


def evaluate_acceptance_criteria(
    train_metrics: dict,
    test_metrics: dict,
    null_model: dict,
) -> dict:
    """Evaluate acceptance criteria from the plan."""
    results = {}

    # AC1: Train lift > 1.5
    results["AC1_train_lift_gt_1.5"] = {
        "criterion": "Train lift > 1.5",
        "value": train_metrics.get("lift", 0),
        "passed": train_metrics.get("lift", 0) > 1.5,
    }

    # AC2: Train p < 0.05 vs null
    results["AC2_train_p_lt_0.05"] = {
        "criterion": "Train p-value < 0.05 vs null model",
        "value": null_model.get("p_value", 1.0),
        "passed": null_model.get("p_value", 1.0) < 0.05,
    }

    # AC3: Test lift > 1.0 (positive signal persists)
    results["AC3_test_lift_gt_1.0"] = {
        "criterion": "Test lift > 1.0",
        "value": test_metrics.get("lift", 0),
        "passed": test_metrics.get("lift", 0) > 1.0,
    }

    # AC4: Test ROI > 0 (positive return)
    results["AC4_test_roi_positive"] = {
        "criterion": "Test ROI > 0%",
        "value": test_metrics.get("roi_pct", 0),
        "passed": test_metrics.get("roi_pct", 0) > 0,
    }

    # AC5: Test lift within 50% of train lift (stability)
    train_lift = train_metrics.get("lift", 0)
    test_lift = test_metrics.get("lift", 0)
    lift_ratio = test_lift / train_lift if train_lift > 0 else 0
    results["AC5_lift_stability"] = {
        "criterion": "Test lift within 50% of train lift (ratio > 0.5)",
        "value": lift_ratio,
        "passed": lift_ratio > 0.5,
    }

    # AC6: Sufficient test sample (n >= 20)
    results["AC6_test_sample_size"] = {
        "criterion": "Test opportunities >= 20",
        "value": test_metrics.get("n_opportunities", 0),
        "passed": test_metrics.get("n_opportunities", 0) >= 20,
    }

    # Overall: All must pass for strategy to be validated
    all_passed = all(r["passed"] for r in results.values())
    results["overall_passed"] = all_passed

    return results


def run_backtest(
    keno_file: str,
    aw_file: str,
    output_file: Optional[str] = None,
) -> BacktestResult:
    """Run complete backtest."""
    logger.info(f"Loading KENO data from {keno_file}")
    keno_df = load_keno_data(keno_file)
    logger.info(f"Loaded {len(keno_df)} KENO draws")

    logger.info(f"Loading AUSWAHLWETTE data from {aw_file}")
    aw_df = load_aw_data(aw_file)
    logger.info(f"Loaded {len(aw_df)} AUSWAHLWETTE draws")

    logger.info("Finding bet opportunities...")
    opportunities = find_bet_opportunities(
        keno_df, aw_df, TRIGGER_NUMBER, TARGET_NUMBER, LAG_DAYS
    )
    logger.info(f"Found {len(opportunities)} potential opportunities")

    # Compute metrics
    logger.info("Computing train metrics...")
    train_metrics = compute_metrics(opportunities, "TRAIN")
    logger.info(f"Train: {train_metrics['n_opportunities']} opportunities, "
                f"lift={train_metrics['lift']:.2f}")

    logger.info("Computing test metrics...")
    test_metrics = compute_metrics(opportunities, "TEST")
    logger.info(f"Test: {test_metrics['n_opportunities']} opportunities, "
                f"lift={test_metrics['lift']:.2f}")

    # Run null model on train data
    logger.info("Running null model (1000 permutations)...")
    null_model = run_null_model(opportunities, "TRAIN", n_permutations=1000)
    logger.info(f"Null model: p={null_model['p_value']:.4f}")

    # Evaluate acceptance criteria
    logger.info("Evaluating acceptance criteria...")
    acceptance = evaluate_acceptance_criteria(train_metrics, test_metrics, null_model)

    # Summary
    overall_summary = {
        "strategy_description": (
            f"When KENO draws {TRIGGER_NUMBER}, bet on {TARGET_NUMBER} "
            f"in AUSWAHLWETTE {LAG_DAYS} days later"
        ),
        "ecosystem_edge": {
            "source": "results/ecosystem_graph.json",
            "trigger": TRIGGER_NUMBER,
            "target": TARGET_NUMBER,
            "lag_days": LAG_DAYS,
            "expected_lift": EXPECTED_LIFT,
            "q_value": 0.027,
        },
        "total_keno_draws": len(keno_df),
        "total_aw_draws": len(aw_df),
        "train_period": f"2022-01-01 to {TRAIN_END}",
        "test_period": f"{TEST_START} to 2025-12-29",
        "conclusion": (
            "VALIDATED" if acceptance["overall_passed"]
            else "NOT VALIDATED - edge may be spurious"
        ),
    }

    result = BacktestResult(
        strategy="KENO->AUSWAHLWETTE lag-7 number coupling",
        trigger_number=TRIGGER_NUMBER,
        target_number=TARGET_NUMBER,
        lag_days=LAG_DAYS,
        train_metrics=train_metrics,
        test_metrics=test_metrics,
        null_model=null_model,
        overall_summary=overall_summary,
        acceptance_criteria=acceptance,
        generated_at=datetime.now().isoformat(),
    )

    # Save output
    if output_file:
        output_path = Path(output_file)
        output_path.parent.mkdir(parents=True, exist_ok=True)

        output_data = {
            "strategy": result.strategy,
            "trigger_number": result.trigger_number,
            "target_number": result.target_number,
            "lag_days": result.lag_days,
            "train_metrics": result.train_metrics,
            "test_metrics": result.test_metrics,
            "null_model": result.null_model,
            "overall_summary": result.overall_summary,
            "acceptance_criteria": result.acceptance_criteria,
            "generated_at": result.generated_at,
        }

        with open(output_path, "w", encoding="utf-8") as f:
            json.dump(output_data, f, indent=2, default=str)
        logger.info(f"Results saved to {output_file}")

    return result


def print_summary(result: BacktestResult) -> None:
    """Print human-readable summary."""
    print("\n" + "=" * 70)
    print("LAG-EXPLOITATION BACKTEST RESULTS")
    print("=" * 70)

    print(f"\nStrategy: {result.strategy}")
    print(f"Trigger: KENO draws {result.trigger_number}")
    print(f"Target: AUSWAHLWETTE draws {result.target_number}")
    print(f"Lag: {result.lag_days} days")

    print("\n--- TRAIN PERIOD (2022-2023) ---")
    tm = result.train_metrics
    print(f"  Opportunities: {tm['n_opportunities']}")
    print(f"  Hits: {tm['n_hits']}")
    print(f"  Hit Rate: {tm['hit_rate']:.1%} (baseline: {BASE_RATE:.1%})")
    print(f"  Lift: {tm['lift']:.2f}x")
    print(f"  ROI: {tm['roi_pct']:.1f}%")

    print("\n--- TEST PERIOD (2024-2025) ---")
    tm = result.test_metrics
    print(f"  Opportunities: {tm['n_opportunities']}")
    print(f"  Hits: {tm['n_hits']}")
    print(f"  Hit Rate: {tm['hit_rate']:.1%} (baseline: {BASE_RATE:.1%})")
    print(f"  Lift: {tm['lift']:.2f}x")
    print(f"  ROI: {tm['roi_pct']:.1f}%")

    print("\n--- NULL MODEL ---")
    nm = result.null_model
    print(f"  Permutations: {nm['n_permutations']}")
    print(f"  Observed Lift: {nm['observed_lift']:.2f}x")
    print(f"  Null Mean Lift: {nm.get('null_mean_lift', 0):.2f}x")
    print(f"  P-value: {nm['p_value']:.4f}")
    print(f"  Significant: {'YES' if nm['is_significant'] else 'NO'}")

    print("\n--- ACCEPTANCE CRITERIA ---")
    ac = result.acceptance_criteria
    for key, val in ac.items():
        if key == "overall_passed":
            continue
        status = "PASS" if val["passed"] else "FAIL"
        print(f"  {key}: {status} ({val['criterion']}, value={val['value']:.3f})")

    print("\n--- CONCLUSION ---")
    print(f"  Overall: {'VALIDATED' if ac['overall_passed'] else 'NOT VALIDATED'}")
    print("=" * 70)


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Backtest Lag-Exploitation Strategy: KENO->AUSWAHLWETTE",
    )
    parser.add_argument(
        "--keno-file",
        default="data/raw/keno/KENO_ab_2022_bereinigt.csv",
        help="Path to KENO CSV file",
    )
    parser.add_argument(
        "--aw-file",
        default="data/raw/auswahlwette/AW_ab_2022_bereinigt.csv",
        help="Path to AUSWAHLWETTE CSV file",
    )
    parser.add_argument(
        "-o", "--output",
        default="results/lag_exploitation_backtest.json",
        help="Output JSON file",
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="Enable verbose output",
    )

    args = parser.parse_args()

    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)

    result = run_backtest(
        keno_file=args.keno_file,
        aw_file=args.aw_file,
        output_file=args.output,
    )

    print_summary(result)


if __name__ == "__main__":
    main()
