---
status: COMPLETE
task: COUPLE-001
role: ARCHITECT
phase: ARCHITECT
files_changed: [AI_COLLABORATION/HANDOFFS/ki5_COUPLE-001_ARCHITECT_20251230_035929.md]
summary:
  - SYSTEM_STATUS.json missing (read error); ADR_AXIOM_FIRST_FRAMEWORK.md reviewed; git status captured.
  - Aim: directed coupling via Transfer Entropy/Conditional MI across specified lags with train/test split and BH/FDR.
  - Proposed working set: kenobase/analysis/alternative_coupling.py, scripts/analyze_alternative_methods.py, kenobase/analysis/number_representations.py, tests/unit/test_alternative_coupling.py.
  - Plan adds kNN-based TE/CMI estimators with lagged conditioning + permutation nulls + FDR per pair/lag (ecosystem vs EuroJackpot control).
  - CLI to surface config (lags, history length, representation) and write JSON results with q-values and metadata under results/.
  - Validation via synthetic directionality tests, smoke run on sample data, and CURRENT_STATUS note post-implementation.
---
# Rule Confirmation
- Rule 1 (SYSTEM_STATUS + ADR/Docs + git status): UNVERIFIED (SYSTEM_STATUS.json missing; ADR_AXIOM_FIRST_FRAMEWORK.md read; git status run)
- Rule 2 (granularity stated): global
- Rule 3 (semantics defined): source/target game pair, lag days, representation (centroid/presence/normalized), TE/CMI stats with permutation p/q, train/test split at 2024-01-01, control flag (EuroJackpot)
- Rule 4 (target metric): accuracy
- Rule 5 (helper-only boundaries): CONFIRMED
- Rule 6 (reproducibility): UNVERIFIED

## Task Setup
- Granularity: global
- Semantics: directed game pairs with lagged TE/CMI conditioned on target history (k_y) and optional source history (k_x), permutation nulls, BH/FDR per pair/lag, ecosystem vs control labeling.
- Target metric: accuracy

## Repro Commands
- UNVERIFIED

# Implementierungsplan
1) Scope & data: confirm available draw CSVs for KENO/LOTTO/EUROJACKPOT and align date coverage; ensure time-series representations (centroid/presence/normalized) are adequate for TE/CMI; define lag grid (e.g., 0/1/2/7 days) and history lengths (k_y target auto-dependence, k_x optional source).
2) API design: extend `CouplingResult` or add new dataclass to carry method, lag, history lengths, q/p, null summary, control flag, train/test split info; add structured container for per-lag/per-direction results and metadata for reproducibility.
3) Estimators: implement TE as conditional mutual information I(X_{t-lag}; Y_t | Y_{t-1..k_y}) using kNN (Kraskov) estimator supporting continuous or discretized inputs; implement CMI baseline (lagged MI without conditioning) for comparison; include robustness guards (NaN handling, min samples).
4) Lag harness: add utility to build lagged matrices from aligned DataFrame columns, respecting missing dates and different frequencies; compute observed TE/CMI per pair/lag/history, with configurable binning/neighbor count; support both scalar and vector representations (flattened presence).
5) Null model & correction: add permutation/block-shuffle null generation preserving target autocorrelation; compute empirical p-values, aggregate across lags, and apply BH/FDR per method/segment; tag results as ecosystem vs EuroJackpot control for sanity checks.
6) CLI integration: extend `scripts/analyze_alternative_methods.py` to expose TE/CMI options (lags, k_y/k_x, n_neighbors/bins, n_permutations, representation choice), run train/test splits, and write JSON with config, data counts, per-pair per-lag results, and summary counts; ensure default output path under `results/`.
7) Testing & validation: add unit tests in `tests/unit/test_alternative_coupling.py` for TE/CMI on synthetic directed vs independent signals (expect higher TE/CMI + low p/q in directed case, near-zero in null), plus smoke test for CLI dry-run with small arrays; document expected CURRENT_STATUS update after implementation (no change made here).
8) Documentation: update docstrings and, if applicable, add brief usage note to README or AI_COLLABORATION/AGENT.md summarizing TE/CMI workflow, required inputs, and negative-control interpretation.

## Acceptance Criteria
- TE/CMI functions compute per-lag metrics with kNN/binning options, return CouplingResult-like objects with p/q and null summaries without NaN crashes on sparse data.
- CLI run `python scripts/analyze_alternative_methods.py --method te --lags 0 1 2 7 --output results/alternative_coupling_te.json` completes on available datasets, writing JSON with config, per-lag results, and FDR-adjusted significance flags (control pairs show <= ecosystem hits).
- Unit tests covering directed vs independent synthetic data for TE and CMI pass; basic CLI smoke test (small synthetic data) passes.
- CURRENT_STATUS note prepared for manual update reflecting architecture plan and pending implementation work (file not modified here).