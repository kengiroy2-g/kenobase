---
status: COMPLETE
task: COUPLE-002
role: ARCHITECT
phase: ARCHITECT
files_changed:
  - AI_COLLABORATION/HANDOFFS/ki5_COUPLE-002_ARCHITECT_20251230_043400.md
summary:
  - SYSTEM_STATUS.json fehlt; Kontext aus CURRENT_STATUS.md und ADR_AXIOM_FIRST_FRAMEWORK.md genutzt (Rule1=UNVERIFIED).
  - Umfang: per-market Cross-Spectrum/Phase-Kopplung fuer Lotterie-Paare mit FDR-korrigierter Signifikanz.
  - Arbeitsset vorgeschlagen: neues kenobase/analysis/cross_spectrum_coupling.py, scripts/analyze_cross_spectrum_coupling.py, tests/unit/test_cross_spectrum_coupling.py, results/cross_spectrum_coupling.json.
  - Plan deckt Daten-Alignment, spektrale Features (CPSD/Coherence/Phase), Nullmodell (Block-Permutation/Phase-Surrogates) und CLI-Ausgabe ab.
  - Tests: synthetische Sinusphasen (bekannte Frequenz/Lag), Negativkontrolle EuroJackpot, CLI-Schema-Check.
---
# Rule Confirmation
- Rule 1 (SYSTEM_STATUS + ADR/Docs + git status): UNVERIFIED (SYSTEM_STATUS.json fehlt; CURRENT_STATUS.md + ADR gelesen)
- Rule 2 (granularity stated): per-market
- Rule 3 (semantics defined): cross-spectrum (CPSD/coherence) + phase-lag/locking per representation/frequency band
- Rule 4 (target metric): accuracy
- Rule 5 (helper-only boundaries): CONFIRMED
- Rule 6 (reproducibility): UNVERIFIED (architecture phase, keine Runs)

## Task Setup
- Granularity: per-market (Lotterie-Paar + Darstellung)
- Semantics: Cross-Spectrum/Coherence + Phase-Differenz/Phase-Locking pro Darstellung und Frequenzband mit BH-q-Werten
- Target metric: accuracy (korrekte Detektion periodischer Kopplung bei kontrollierter FDR)

## Repro Commands
- UNVERIFIED (architektur; keine Kommandos ausgefuehrt)

# Implementierungsplan
1. Anforderungen schaerfen: Ziel ist Inverse/periodische Kopplung zwischen Lotterien ueber Cross-Spectrum/Phase; festlegen welche Darstellungen (z.B. Zahl-Indicators, Summen/Dekaden) und Frequenzbaender relevant (tages/woechentliche Periodik, Ziehungsrhythmus).
2. Betroffene Dateien (Working Set): neues Modul `kenobase/analysis/cross_spectrum_coupling.py`; CLI `scripts/analyze_cross_spectrum_coupling.py` (oder Erweiterung bestehender Coupling-CLI); Tests `tests/unit/test_cross_spectrum_coupling.py`; optional `kenobase/core/data_loader.py`/`kenobase/core/timeline.py` falls Alignment/Metadata erweitert werden; Ergebnis-Schema `results/cross_spectrum_coupling.json`.
3. Datenbasis & Alignment: Wiederverwende GameDraws/Timeline-Utilities aus `cross_lottery_coupling` zur Synchronisation unterschiedlicher Ziehungsplaene; definiere Sampling-Grid (z.B. tägliche Slots) und Missing-Handling (Padding/Interpolation verboten, stattdessen Masking).
4. Darstellungen & Preprocessing: Nutze vorhandene `number_representations` (z.B. numbers_onehot, ordered_value, sum_signature) um je Spiel zeitliche Signale abzuleiten; optional Glätten/Windowing (Hann) vor FFT/Welch; Normalisierung (z-score) pro Serie.
5. Spektrale Kopplungsmetriken: Implementiere CPSD/Coherence via `scipy.signal.csd/coherence` (Welch, konfigurierbare Segmentlaenge/Overlap); berechne Phase-Differenzen (angle der CPSD), Phase-Locking Value/Index fuer Frequenzbaender; aggregiere Kennzahlen (dominante Frequenz, Peak-Coherence, mittlere Phase je Band) pro Paar/Darstellung.
6. Nullmodell & Signifikanz: Baue Block-Permutations- oder Phase-Randomisierungs-Surrogates, die saisonale Struktur erhalten; compute p/q-Werte per Frequenzband und global (Peak-Test), BH-FDR Korrektur pro Methode/Representation; verifiziere Negative Control (EuroJackpot) wird nicht spurios signifikant.
7. CLI/Output: CLI-Entry akzeptiert Spiele/Representations/Frequenzbaender/Window-Parameter; schreibt `results/cross_spectrum_coupling.json` mit Serien-Metadaten, Bands, Peaks, Phase-Lags, p/q-Werten und ggf. Kontrolle-Flags; Logging der Parameter ins Ergebnis.
8. Tests & Validierung: Unit-Tests mit synthetischen Sinus-Signalen mit bekannter Frequenz/Phase-Lag (soll korrekte Peak-Frequenz und Phase erkennen), Nullkontroll-Test mit unabhängigen Rauschserien, und CLI-Schema-Test (JSON Felder/q-Werte vorhanden); Smoke-Command fuer CLI dokumentieren.
9. Acceptance Criteria: (a) Funktionen liefern Coherence + Phase-Lags pro Band mit BH-q <= alpha markiert; (b) CLI erzeugt reproduzierbares JSON und respektiert Negative-Control; (c) Unit-Tests fuer Synth/Null/CLI bestehen; (d) Dokumentierte Repro-Kommandos fuer Tests + Standard-Run vorhanden.